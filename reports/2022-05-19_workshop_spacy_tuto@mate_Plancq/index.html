<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="../../sunset.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		
		<link href="../../_app/immutable/assets/0.D0TAEvq0.css" rel="stylesheet">
		<link rel="modulepreload" href="../../_app/immutable/entry/start.B9fD-3Wj.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/ATQqNzrN.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/CXCHmQ-B.js">
		<link rel="modulepreload" href="../../_app/immutable/entry/app.DF3f1qoj.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/C1FmrZbK.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/DuaWf0Pd.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/0.HaHf7Tap.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/DKuRuggZ.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/7.BTHH_Nau.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/BheWnx7M.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/D2-NGLRx.js"><!-- HEAD_svelte-1i32evn_START --><!-- HEAD_svelte-1i32evn_END -->
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">     <div class="content">  <nav class="svelte-epptjw"> <a href="/" class="svelte-epptjw" data-svelte-h="svelte-4ebbsj"><h1 class="svelte-epptjw">/log</h1></a> <ul class="svelte-epptjw"><li><a href="/reports" class="svelte-epptjw active" data-svelte-h="svelte-12wekpw">Comptes rendus</a></li> <li><a href="/notes" class="svelte-epptjw" data-svelte-h="svelte-eu7epz">Notes</a></li> <li><a href="/projets" class="svelte-epptjw" data-svelte-h="svelte-4lv15p">Projets</a></li>  <li><button class="switch svelte-epptjw" role="switch" aria-checked="true"></button></li></ul></nav>   <main>  <article><p class="date">19 mai 2022</p> <p class="speaker">Clément Plancq</p> <h1 data-svelte-h="svelte-1nkrmnk">Tuto@mate - de l’utilisation de spaCy, comment parser un texte avec une bibliothèque Python</h1> <h2 data-svelte-h="svelte-g1gtei">Ressources</h2> <ul data-svelte-h="svelte-1sfcbuq"><li><a href="https://github.com/clement-plancq/tuto-mate" rel="nofollow">Notebook du tuto@mate</a> pour tester le code sans installer Python et spaCy (cliquer sur launch binder dans le README.md)</li> <li><a href="https://course.spacy.io/fr/" rel="nofollow">Cours par Ines Montani</a></li></ul> <h2 data-svelte-h="svelte-1ukekoe">Introduction</h2> <p data-svelte-h="svelte-fogvb4">SpaCy est un librairie Python pour le TAL, developpée par Matthew Honnibal et Ines Montani. C’est une bibliothèque Python pour le traitement des TAL sous licence libre (MIT 2.0), bien que distribuer par une société privée. En revanche les modèles sont distribués sous divers licences ouvertes (liées aux documents qui ont permis leur élaboration).</p> <p data-svelte-h="svelte-1ixut60">SpaCy est destiné à êter utilisé en production : donc traitement rapide, stable, qualité du code (test, documentation, etc.). Mais pas de chois dans le méthode ou l’algorithme utilisé. On sait ce qui est utilisé, c’est documenté, mais on ne peut pas modifier ces paramètres.</p> <p data-svelte-h="svelte-9ncpi3">Peut faire :</p> <ul data-svelte-h="svelte-89vpcj"><li>tokenisation</li> <li>étiquetage POS (verbe, nom, etc.)</li> <li>analyse syntaxique</li> <li>detection d’entités nommées</li> <li>lemmatisation</li> <li>catégorisation de texte</li> <li>word embedding</li></ul> <p data-svelte-h="svelte-1yb6fsm">SpaCy utilise des modèles statistique (méthode neuronales).</p> <p data-svelte-h="svelte-1l7621r">Intérêts : c’est dy Python (wrapper R également), simple à prendre en main, très bien documenté (doc, tuto, etc.), grosse communauté sur github, fournit les méthodes et les moyens d’adapter le traitement et ou le modèle à des besoins particuliers ! Mais ce n’est pas forcément l’outils qui sera le meilleurs pour le français dans toutes les tâches de TAL.</p> <p data-svelte-h="svelte-dtqr8k">Il existe d’autre frameworks pour le TAL</p> <ul data-svelte-h="svelte-g9uolk"><li>NLKT : python, orienté pédagogie, chois des méthodes et algos à utiliser</li> <li>CoreNLP : java, framework de Stanford, orienté recherche, chaîne de TAL la plus complète pour l’anglais</li> <li>Stanza : python, framework de Stanford également, modèle neuronaux entraînés sur les données d’Universal Dependancies (il y a un module spacy-stanza pour utiliser les modèles de Stanza</li> <li>Flair : python, framewok de Zalando (site de e-commerce), peut être le plus performant sur la reconnaissance d’entités nommées</li></ul> <p data-svelte-h="svelte-169phrd">Les modèles de spaCy
SpaCy utilise des modèles statistiques qui permettent de prédire des annotations linguistiques (identifier un verbe, un nom, le sentiment d’une phrase).
21 langues prise en compte. La qualité des résultats dépend beaucoup du corpus sur lequel s’est entraîné le modèle.
Pour le français, il y a 3 modèles + 1. Il sont tous issus du corpus <a href="http://www.linguist.univ-paris-diderot.fr/~mcandito/Publications/candito-seddah-taln2012.pdf" rel="nofollow">Sequoia</a> (wikipedia + presse (Est-républicain) + Agence euro du médicament, Europarl) et WikiNer, sauf le modèle trf, qui est issu de camembert-base (modèle Bert), distribué par Hugginf Face, entraîné sur Oscar.</p> <p data-svelte-h="svelte-xt0p3n">Le choix du modèle est vraiment primordial pour les traitements.</p> <h2 data-svelte-h="svelte-1l3kxey">Étape de la chaîne de traitement</h2> <h3 data-svelte-h="svelte-ayx0qe">Tokenisation</h3> <p data-svelte-h="svelte-188d52t">Opération qui consiste à découper un texte ou chaîne de caractères en token. En linguistique il n’y a pas de définition précise de « mot », on parle alors de token. Les signes de ponctuation sont tokénisés.</p> <p data-svelte-h="svelte-twcz49">L’intérêt de spaCy, c’est que sa tokénisation n’est pas destructive. On peut donc, à partir de la tokenisation, reformer le texte (conservation des espaces par exemple).</p> <p data-svelte-h="svelte-1r7hqkf">Il est possible de modifier la tokenisation par défaut.</p> <p data-svelte-h="svelte-zt8fsk">Concernant la tokénisation, SpaCy permet aussi de récupérer des groupes nominaux. Il est également possible de récupérer les phrases d’un texte.</p> <h3 data-svelte-h="svelte-9tk5gg">Étiquetage (tagging)</h3> <p data-svelte-h="svelte-1n1zpla">Étape qui permet, pour chaque token de déterminer s’il s’agit d’un verbe, du adjectif, d’un nom, etc.</p> <pre class="language-python"><!-- HTML_TAG_START --><code class="language-python">doc <span class="token operator">=</span> nlp<span class="token punctuation">(</span><span class="token string">"Tous mes beaux châteaux d'Équateur s'écroulent."</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> tok <span class="token keyword">in</span> doc<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>tok<span class="token punctuation">,</span> tok<span class="token punctuation">.</span>pos_<span class="token punctuation">)</span></code><!-- HTML_TAG_END --></pre> <blockquote data-svelte-h="svelte-kzzplv"><p>Tous ADJ
mes DET
beaux ADJ
châteaux NOUN
d’ ADP
Équateur PROPN
s’ PRON
écroulent VERB
. PUNCT</p></blockquote> <p data-svelte-h="svelte-yv1kd0">Les annotation portant sur les token sont accessibles via les attributs des objets de type token</p> <ul data-svelte-h="svelte-vocjgu"><li>pos_ contient l’étiquette de partie du discours de universal dependancies</li> <li>tag_ contient l’étiquette du corpus original, parfois plus détaillée</li> <li>lemma_ pour le lemme</li> <li>morph pour l’analyse morphologique</li></ul> <pre class="language-python"><!-- HTML_TAG_START --><code class="language-python"><span class="token keyword">for</span> token <span class="token keyword">in</span> doc<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>token<span class="token punctuation">,</span> token<span class="token punctuation">.</span>lemma_<span class="token punctuation">,</span> token<span class="token punctuation">.</span>pos_<span class="token punctuation">,</span> token<span class="token punctuation">.</span>morph<span class="token punctuation">)</span></code><!-- HTML_TAG_END --></pre> <blockquote data-svelte-h="svelte-12j9sc5"><p>Tous tout ADJ Gender=Masc|Number=Plur
mes mon DET Number=Plur|Poss=Yes
beaux beal ADJ Gender=Masc|Number=Plur
châteaux château NOUN Gender=Masc|Number=Plur
d’ de ADP
Équateur Équateur PROPN
s’ se PRON Person=3|Reflex=Yes
écroulent écrouler VERB Mood=Ind|Number=Plur|Person=3|Tense=Pres|VerbForm=Fin
. . PUNCT</p></blockquote> <h3 data-svelte-h="svelte-11hjjw4">Détection d’entités nommées (ner)</h3> <p data-svelte-h="svelte-37r4y2">Pour repérer les noms de personnes, de lieux, d’organisation, miscelannée et parfois même les dates.</p> <p data-svelte-h="svelte-8tedxk">Il y a également dans spaCy un visualiseur, qui permet d’avoir une représentation visuel du traitement du texte en html.</p> <p data-svelte-h="svelte-1cbgjnp">Il est possible d’adapter la reconnaissance des entités nommées, voire même d’entrainer d’autres modèles.</p> <h3 data-svelte-h="svelte-19wnw9b">Analyse syntaxique (parsing)</h3> <p data-svelte-h="svelte-1ect0ua">C’est une analyse en dépendance avec spaCy. Dans ce type d’analyse, chaque mot d’une phrase à un gouverneur unique (head), la relation de dépendance entre le mot et son gouverneur est typée (nsubj, obj, etc.) Pour la tête de la phrase on utilise la relation ROOT.</p> <p data-svelte-h="svelte-1fcas5u">La structure produite par l’analyse syntaxique est un arbre, un graphe acyclique et connexe.
Les tokens sont les nœuds, les arcs sont les dépendances, le type de la relation est l’étiquette de l’arc.</p> <pre class="language-python"><!-- HTML_TAG_START --><code class="language-python">doc <span class="token operator">=</span> nlp<span class="token punctuation">(</span><span class="token string">"Il te refile en stéréo la chanson des sirènes."</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> token <span class="token keyword">in</span> doc<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>token<span class="token punctuation">,</span> token<span class="token punctuation">.</span>dep_<span class="token punctuation">,</span> token<span class="token punctuation">.</span>head<span class="token punctuation">)</span></code><!-- HTML_TAG_END --></pre> <blockquote data-svelte-h="svelte-jsh8p4"><p>Il expl:subj refile
te iobj refile
refile ROOT refile
en case stéréo
stéréo obl:arg refile
la det chanson
chanson obj refile
des case sirènes
sirènes nmod chanson
. punct refile</p></blockquote> <p data-svelte-h="svelte-1crldaq">Il existe aussi une représentation graphique de la dépendance des tokens entre eux.</p> <p data-svelte-h="svelte-sd9oro">Dans l’analyse en dépendance on peut aussi parcourir l’arbre de dépendance. Les attributs de token suivant peuvent être utilisés pour parcourir l’arbre de dépendance :</p> <ul data-svelte-h="svelte-1cogdop"><li><code>children</code> les tokens dépendants du token</li> <li><code>subtree</code> tous les descendants du token</li> <li><code>ancestors</code> tous les parents du token</li> <li><code>rights</code> les enfants à droite du token</li> <li><code>lefts</code> les enfants à gauche du token</li></ul> <pre class="language-python"><!-- HTML_TAG_START --><code class="language-python">root <span class="token operator">=</span> <span class="token punctuation">[</span>token <span class="token keyword">for</span> token <span class="token keyword">in</span> doc <span class="token keyword">if</span> token<span class="token punctuation">.</span>head <span class="token operator">==</span> token<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
subjects <span class="token operator">=</span> <span class="token punctuation">[</span>tok <span class="token keyword">for</span> tok <span class="token keyword">in</span> root<span class="token punctuation">.</span>lefts <span class="token keyword">if</span> <span class="token string">"subj"</span> <span class="token keyword">in</span> tok<span class="token punctuation">.</span>dep_<span class="token punctuation">]</span>
subject <span class="token operator">=</span> subjects<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
objs <span class="token operator">=</span> <span class="token punctuation">[</span>tok <span class="token keyword">for</span> tok <span class="token keyword">in</span> root<span class="token punctuation">.</span>rights <span class="token keyword">if</span> tok<span class="token punctuation">.</span>dep_ <span class="token operator">==</span> <span class="token string">"obj"</span><span class="token punctuation">]</span>
obj <span class="token operator">=</span> objs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"sujet : </span><span class="token interpolation"><span class="token punctuation">&#123;</span>subject<span class="token punctuation">&#125;</span></span><span class="token string">, prédicat : </span><span class="token interpolation"><span class="token punctuation">&#123;</span>root<span class="token punctuation">&#125;</span></span><span class="token string">, objet : </span><span class="token interpolation"><span class="token punctuation">&#123;</span>obj<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span></code><!-- HTML_TAG_END --></pre> <blockquote data-svelte-h="svelte-14w7u1i"><p>sujet : Il, prédicat : refile, objet : chanson</p></blockquote> <h2 data-svelte-h="svelte-1l8s3lo">Extraction d’information</h2> <p data-svelte-h="svelte-didik0">À partir de tous ces traitements, il est possible d’effectuer d’autres opérations.
Spacy a une classe Matcher qui permet de repérer des tokens ou des séquences de tokens à l’aide de patrons (pattern).
Ces patrons peuvent porter sur la forme des tokens ou leurs attributs (pos, ent, …).
On peut aussi utiliser des catégories comme IS_ALPHA ou IS_NUM, voir la doc
(Il existe une démo avec interface graphique mais pas pour le français 🙁)</p> <pre class="language-python"><!-- HTML_TAG_START --><code class="language-python"><span class="token keyword">from</span> spacy<span class="token punctuation">.</span>matcher <span class="token keyword">import</span> Matcher
doc <span class="token operator">=</span> nlp<span class="token punctuation">(</span><span class="token string">"Ce modèle est aussi disponible en taille XL ; je vous le conseille."</span><span class="token punctuation">)</span>
matcher <span class="token operator">=</span> Matcher<span class="token punctuation">(</span>nlp<span class="token punctuation">.</span>vocab<span class="token punctuation">)</span>

pattern <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token string">"LOWER"</span><span class="token punctuation">:</span> <span class="token string">"en"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token string">"LOWER"</span><span class="token punctuation">:</span> <span class="token string">"taille"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token string">"IS_ALPHA"</span><span class="token punctuation">:</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token string">"IS_UPPER"</span><span class="token punctuation">:</span> <span class="token boolean">True</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span>
<span class="token comment">#pattern : 'en' + 'taille' + lettres en maj</span>

matcher<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">"tailles"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>pattern<span class="token punctuation">]</span><span class="token punctuation">)</span>
matches <span class="token operator">=</span> matcher<span class="token punctuation">(</span>doc<span class="token punctuation">)</span>
<span class="token keyword">for</span> _<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end <span class="token keyword">in</span> matches<span class="token punctuation">:</span>
    span <span class="token operator">=</span> doc<span class="token punctuation">[</span>start<span class="token punctuation">:</span>end<span class="token punctuation">]</span>  <span class="token comment"># The matched span</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">&#123;</span>span<span class="token punctuation">.</span>text<span class="token punctuation">&#125;</span></span><span class="token string"> (</span><span class="token interpolation"><span class="token punctuation">&#123;</span>start<span class="token punctuation">&#125;</span></span><span class="token string">, </span><span class="token interpolation"><span class="token punctuation">&#123;</span>end<span class="token punctuation">&#125;</span></span><span class="token string">)"</span></span><span class="token punctuation">)</span></code><!-- HTML_TAG_END --></pre> <blockquote data-svelte-h="svelte-1gl5z27"><p>en taille XL (5, 8)</p></blockquote> <p data-svelte-h="svelte-7o74nv">Ça fonctionne pour les séquences comme « en taille M » ou « en taille XL » mais pas pour « vous l’avez en XL ? »</p> <p data-svelte-h="svelte-g325eo">C’est un patron de repérage de séquences de mots. Il est possible de rechercher aussi des regEx.</p> <p data-svelte-h="svelte-1bgnoir">Pour les entités nommées, parfois ça fonctionne mal avec le français (prénoms mal étiqueté, comme misc par exemple), il est donc possible de travailler avec des patrons pour correctement étiqueter les entités nommées, à partir d’un liste de noms par exemple.</p> <p data-svelte-h="svelte-zz27la">Depuis la v3 de spaCy, il y a un nouvel outil, Dependency Matcher qui permet de faire de l’extraction de patrons syntaxiques. On peut faire porter les requêtes sur l’arbre syntaxique et non plus seulement sur la séquence des tokens.
Permet aussi de tirer des informations sur un texte, à partir de pattern précis
Par exemple récupérer tous tokens qui sont les lemmes de « acheter » ou « vendre », puis d’analyser les dépendances de ces tokens pour extraite, par exemple, le sujet et l’objet.</p> <p data-svelte-h="svelte-175sjvu">Une critique, c’est que spaCy ne prend pas le format sql (pris en charge par txm par exemple).</p> <h2 data-svelte-h="svelte-1w26jsl">Adaptation du modèle</h2> <h3 data-svelte-h="svelte-1sob5kz">L’exemple des entités nommées</h3> <p data-svelte-h="svelte-j69u7p">La taille et la nature du corpus d’entraînement seront déterminantes. Il est possible d’amender un modèle existant avec un jeu de données annotées de taille réduite.
Exemple sur les entités nommées mais la procèdure d’entraînement fonctionne pour d’autres niveaux d’annotations (pos, dépendance)
Voir la <a href="https://spacy.io/usage/training" rel="nofollow">doc</a>.</p> <p data-svelte-h="svelte-plu7oa">SpaCy propose aussi des outils pour évaluer les performance des modèles que l’on a généré, ainsi que des mécanismes d’export et d’import des modèles et des données.</p> <p data-svelte-h="svelte-1rz72dk">Il ne faut pas avoir peur de faire son propre modèle, pour le traitement d’un corpus spécifique, ce n’est pas forcément très long à faire.</p></article></main>   <footer class="svelte-1capoi1" data-svelte-h="svelte-1h3xx8c"><nav><ul class="svelte-1capoi1"><li><a href="https://github.com/sardinecan/log" class="svelte-1capoi1">Github</a></li> </ul></nav></footer> </div> 
			
			<script>
				{
					__sveltekit_fy0s1o = {
						base: new URL("../..", location).pathname.slice(0, -1)
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("../../_app/immutable/entry/start.B9fD-3Wj.js"),
						import("../../_app/immutable/entry/app.DF3f1qoj.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 7],
							data: [null,null],
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
